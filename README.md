# Interop Between Java and Scala

*Declaration: Content forked form the http://www.codecommit.com/blog/java/interop-between-java-and-scala, only for compare study and record learning experience*

- [Interop Between Java and Scala](#Interop%20Between%20Java%20and%20Scala)
    - [Classes are Classes](#classes-are-classes)
    - [Traits are Interfaces](#traits-are-interfaces)
    - [Generics are, well Generics](#generics-are-well-generics)
    - [Operators are Methods](#operators-are-methods)
    - [Odds and Ends](#odds-and-ends)
    - [Conclusion](#conclusion)
    - [Javap反编译](#Javap%E5%8F%8D%E7%BC%96%E8%AF%91)
    - [Java to Scala cheatsheet](#java-to-scala-cheatsheet)
    - [From Scala](#from-scala)

Sometimes, the simplest things are the most difficult to explain.  Scala's interoperability with Java is completely unparalleled, even including languages like Groovy which tout their tight integration with the JVM's venerable standard-bearer.  However, despite this fact, there is almost no documentation (aside from chapter 29 in _Programming in Scala_) which shows how this Scala/Java integration works and where it can be used.  So while it may not be the most exciting or theoretically interesting topic, I have taken it upon myself to fill the gap.

### Classes are Classes

The first piece of knowledge you need about Scala is that Scala classes are real JVM classes.  Consider the following snippets, the first in Java:

```java
// java code:    
    
    public class Person {
        public String getName() {
            return "Daniel Spiewak";
        }
    }

``` 

…and the second in Scala:

```scala
// scala code:    
    
    class Person {
      def getName() = "Daniel Spiewak"
    }

``` 

Despite the very different syntax, both of these snippets will produce almost identical bytecode when compiled.  Both will result in a single file, `Person.class`, which contains a default, no-args constructor and a public method, `getName()`, with return type `java.lang.String`.  Both classes may be used from Scala:

```scala
// scala code:    
    
    val p = new Person()
    p.getName()       // => "Daniel Spiewak"

``` 

…and from Java:

```java
// java code:    
    
    Person p = new Person();
    p.getName();      // => "Daniel Spiewak"

``` 

In the case of either language, we can easily swap implementations of the `Person` class without making any changes to the call-site.  In short, you can use Scala classes from Java (as well as Java classes from Scala) without ever even knowing that they were defined within another language.

This single property is the very cornerstone of Scala's philosophy of bytecode translation.  Wherever possible — and that being more often than not — Scala elements are translated into bytecode which _directly_ corresponds to the equivalent feature in Java.  Scala classes equate to Java classes, methods and fields within those classes become Java methods and fields.

This allows some pretty amazing cross-language techniques.  For example, I can extend a Java class within Scala, overriding some methods.  I can in turn extend this Scala class from within Java once again with everything working exactly as anticipated:

```scala
// scala code:    
    
    class MyAbstractButton extends JComponent {
      private var pushed = false
     
      def setPushed(p: Boolean) {
        pushed = p
      }
     
      def getPushed = pushed
     
      override def paintComponent(g: Graphics) {
        super.paintComponent(g)
     
        // draw a button
      }
    }

``` 

```java
// java code:    
    
    public class ProKitButton extends MyAbstractButton {
        // do something uniquely Apple-esque
    }

``` 

### Traits are Interfaces

This is probably the one interoperability note which is the _least_ well-known.  Scala's traits are vastly more powerful than Java's interfaces, often leading developers to the erroneous conclusion that they are incompatible.  Specifically, traits allow method definitions, while interfaces must be purely-abstract.  Yet, despite this significant distinction, Scala is still able to compile traits into interfaces at the bytecode level…with some minor enhancements.

The simplest case is when the trait only contains abstract members.  For example:

```scala
// scala code:    
    
    trait Model {
      def value: Any
    }

``` 

If we look at the bytecode generated by compiling this trait, we will see that it is actually equivalent to the following Java definition:

```java
// java code:    
    
    public interface Model {
        public Object value();
    }

``` 

Thus, we can declare traits in Scala and implement them as interfaces in Java classes:

```java
// java code:    
    
    public class StringModel implements Model {
        public Object value() {
            return "Hello, World!";
        }
    }

``` 

This is precisely equivalent to a Scala class which mixes-in the `Model` trait:

```scala
// scala code:    
    
    class StringModel extends Model {
      def value = "Hello, World!"
    }

``` 

Things start to get a little sticky when we have method definitions within our traits.  For example, we could add a `printValue()` method to our `Model` trait:

```scala
// scala code:    
    
    trait Model {
      def value: Any
     
      def printValue() {
        println(value)
      }
    }

``` 

Obviously, we can't directly translate this into _just_ an interface; something else will be required.  Scala solves this problem by introducing an ancillary class which contains all of the method definitions for a given trait.  Thus, when we look at the translation for our modified `Model` trait, the result looks something like this:

```java
// java code:    
    
    public interface Model extends ScalaObject {
        public Object value();
     
        public void printValue();
    }
     
    public class Model$class {
        public static void printValue(Model self) {
            System.out.println(self.value());
        }
    }

``` 

Thus, we can get the _effect_ of Scala's powerful mixin inheritance within Java by implementing the `Model` trait and delegating from the `printValue()` method to the `Model$class` implementation:

```java
// java code:    
    
    public class StringModel implements Model {
        public Object value() {
            return "Hello, World!";
        }
     
        public void printValue() {
            Model$class.printValue(this);
        }
     
        // method missing here (see below)
    }

``` 

It's not perfect, but it allows us to use some of Scala's more advanced trait-based functionality from within Java.  Incidentally, the above code _does_ compile without a problem.  I wasn't actually aware of this fact, but "`$`" is a legal character in Java identifiers, allowing interaction with some of Scala's more interesting features.

There is, however, one little wrinkle that I'm conveniently side-stepping: the `$tag` method.  This is a method defined within the `ScalaObject` trait designed to help optimize pattern matching.  Unfortunately, it also means yet another abstract method which must be defined when implementing Scala traits which contain method definitions.  The correct version of the `StringModel` class from above actually looks like the following:

```java
// java code:    
    
    public class StringModel implements Model {
        public Object value() {
            return "Hello, World!";
        }
     
        public void printValue() {
            Model$class.printValue(this);
        }
     
        public int $tag() {
            return 0;
        }
    }

``` 

To be honest, I'm not sure what is the "correct" value to return from `$tag`.  In this case, `0` is just a stub, and I'm guessing a safe one since `StringModel` is the only subtype of `Model`.  Can anyone who knows more about the Scala compiler shed some light on this issue?

### Generics are, well Generics

Generics are (I think) probably the coolest and most well-done part of Scala's Java interop.  Anyone who has more than a passing familiarity with Scala will know that its type system is significantly more powerful than Java's.  Some of this power comes in the form of its type parameterization, which is vastly superior to Java's generics.  For example, type variance can be handled at declaration-site, rather than only call-site (as in Java):

```java
// java code:    
    
    abstract class List[+A] {
      ...
    }

``` 

The `+` notation prefixing the `A` type parameter on the `List` class means that `List` will vary covariantly with its parameter.  In English, this means that `List[String]` is a subtype of `List[Any]` (because `String` is a subtype of `Any`).  This is a very intuitive relationship, but one which Java is incapable of expressing.

Fortunately, Scala is able to exploit one of the JVM's most maligned features to support things like variance and higher-kinds without sacrificing perfect Java interop.  Thanks to type erasure, Scala generics can be compiled to Java generics without any loss of functionality on the Scala side.  Thus, the Java translation of the `List` definition above would be as follows:

```java
// java code:    
    
    public abstract class List {
        ...
    }

``` 

The variance annotation is gone, but Java wouldn't be able to make anything of it anyway.  The huge advantage to this translation scheme is it means that Java's generics and Scala's generics are one and the same at the bytecode level.  Thus, Java can use generic Scala classes without a second thought:

```java
// java code:    
    
    import scala.Tuple2;
     
    ...
    Tuple2 me = new Tuple2("Daniel", "Spiewak");

``` 

Obviously, this is a lot more verbose than the Scala equivalent, "`("Daniel", "Spiewak")`", but at least it works.

### Operators are Methods

One of the most obvious differences between Java and Scala is that Scala supports operator overloading.  In fact, Scala supports a variant of operator overloading which is far stronger than anything offered by C++, C# or even Ruby.  With very few exceptions, _any_ symbol may be used to define a custom operator.  This provides tremendous flexibility in DSLs and even your average, every-day API (such as `List` and `Map`).

Obviously, this particular language feature is not going to translate into Java quite so nicely.  Java doesn't support operator overloading of _any_ variety, much less the über-powerful form defined by Scala.  Thus, Scala operators must be compiled into an entirely non-symbolic form at the bytecode level, otherwise Java interop would be irreparably broken, and the JVM itself would be unable to swallow the result.

A good starting place for deciding on this translation is the way in which operators are declared in Scala: as methods.  Every Scala operator (including unary operators like `!`) is defined as a method within a class:

```scala
// scala code:    
    
    abstract class List[+A] {
      def ::[B >: A](e: B) = ...
     
      def +[B >: A](e: B) = ...
    }

``` 

Since Scala classes become Java classes and Scala methods become Java methods, the most obvious translation would be to take each operator method and produce a corresponding Java method with a heavily-translated name.  In fact, this is exactly what Scala does.  The above class will compile into the equivalent of this Java code:

```java
// java code:    
    
    public abstract class List {
        public  List $colon$colon(B e) { ... }
     
        public  List $plus(B e) { ... }
    }

``` 

Every allowable symbol in Scala's method syntax has a corresponding translation of the form "`$`_trans_".  A list of supported translations is one of those pieces of documentation that you would expect to find on the Scala website.  However, alas, it is absent.  The following is a table of all of the translations of which I am aware:

|Scala Operator	| Compiles To   |
| ------------- |:-------------:|
| = | $eq |
| > | $greater |
| < | $less |
| + | $plus |
| - | $minus |
| * | $times |
| / | div |
| ! | $bang |
| @ | $at |
| # | $hash |
| % | $percent |
| ^ | $up |
| & | $amp |
| ~ | $tilde |
| ? | $qmark |
| | | $bar |
| \ | $bslash |
| : | $colon |

Using this table, you should be able to derive the "real name" of any Scala operator, allowing its use from within Java.  Of course, the idea solution would be if Java actually supported operator overloading and could use Scala's operators directly, but somehow I doubt that will happen any time soon.

### Odds and Ends

One final tidbit which might be useful: `@BeanProperty`.  This is a special annotation which is essentially read by the Scala compiler to mean "generate a getter and setter for this field":

```scala
// scala code:    
    
    import scala.reflect.BeanProperty
     
    class Person {
      @BeanProperty
      var name = "Daniel Spiewak"
    }

``` 

The need for this annotation comes from the fact that Scala's ever-convenient `var` and `val` declarations actually generate code which looks like the following (assuming no `@BeanProperty` annotation):

```java
// java code:    
    
    // *without* @BeanProperty
    public class Person {
        private String name = "Daniel Spiewak";
     
        public String name() {
            return name;
        }
     
        public void name_$eq(String name) {
            this.name = name;
        }
    }

``` 

This works well from Scala, but as you can see, Java-land is not quite paradise.  While it is certainly feasible to use the `_$eq` syntax instead of the familiar `set`/`get`/`is` triumvirate, it is not an ideal situation.

Adding the `@BeanProperty` annotation (as we have done in the earlier Scala snippet) solves this problem by causing the Scala compiler to auto-generate more than one pair of methods for that particular field.  Rather than just `value` and `value_$eq`, it will also generate the familiar `getValue` and `setValue` combination that all Java developers will know and love.  Thus, the actual translation resulting from the `Person` class in Scala will be as follows:

```java
// java code:    
    
    public class Person {
        private String name = "Daniel Spiewak";
     
        public String name() {
            return name;
        }
     
        public String getName() {
            return name();
        }
     
        public void name_$eq(String name) {
            this.name = name;
        }
     
        public void setName(String name) {
            name_$eq(name);
        }
    }

``` 

This merely provides a pair of delegates, but it does suffice to smooth out the mismatch between Java Bean-based frameworks and Scala's elegant instance fields.

### Conclusion

This has been a whirlwind, disjoint tour covering a fairly large slice of information on how to use Scala code from within Java.  For the most part, things are all roses and fairy tales.  Scala classes map precisely onto Java classes, generics work perfectly, and pure-abstract traits correspond directly to Java interfaces.  Other areas where Scala is decidedly more powerful than Java (like operators) do tend to be a bit sticky, but there is _always_ a way to make things work.

If you're considering mixing Scala and Java sources within your project, I hope that this article has smoothed over some of the doubts you may have had regarding its feasibility.  As David Pollack says, Scala is really "just another Java library".  Just stick `scala-library.jar` on your classpath and all of your Scala classes should be readily available within your Java application.  And given how well Scala integrates with Java at the language level, what could be simpler?

### Javap反编译

```bash
daniel@lal ~ $ javap -classpath /usr/local/scala-2.7.3.final/lib/scala-library.jar scala.Function1$class
Compiled from "Function1.scala"
public interface scala.Function1 extends scala.ScalaObject{
    public abstract scala.Function1 andThen(scala.Function1);
    public abstract scala.Function1 compose(scala.Function1);
    public abstract java.lang.String toString();
    public abstract java.lang.Object apply(java.lang.Object);
}

daniel@lal ~ $ javap -classpath /usr/local/scala-2.7.3.final/lib/scala-library.jar scala.ScalaObject
Compiled from "ScalaObject.scala"
public interface scala.ScalaObject{
    public abstract int $tag()       throws java.rmi.RemoteException;
}

daniel@lal ~ $ javap -classpath /usr/local/scala-2.7.3.final/lib/scala-library.jar 'scala.Function1$class'
Compiled from "Function1.scala"
public abstract class scala.Function1$class extends java.lang.Object{
    public static void $init$(scala.Function1);
    public static scala.Function1 andThen(scala.Function1, scala.Function1);
    public static scala.Function1 compose(scala.Function1, scala.Function1);
    public static java.lang.String toString(scala.Function1);
}

```

# ---------------------------------

# [Java to Scala cheatsheet](http://rea.tech/java-to-scala-cheatsheet/)

We've started some new work in Scala!  Most of the back-end developers in the Residential team have a Java background though,  so we put together this cheatsheet to help get the team started.

Scala does almost everything Java does, plus a whole lot of useful functional stuff.  There's a direct analog in Scala for almost everything in Java.

Keep in mind though, real idiomatic Scala needs a bit more than just Java semantics — there's lots of really powerful and useful functional features and idioms that you can learn as you go.

```java
// java code:
    @interface Foo {
    
    }
```
```scala
// scala code:
    trait Foo extends StaticAnnotation {
    
    }
```
* There is no special syntax for annotation definitions.
* An annotation has to extend scala.Annotation, or one of its sub-traits.
* Scala's compiler will stitch it into the necessary bytecode form for use in Scala or Java.

```java
// java code:
    @Foo
    public class Blah {
      @Stuff
      public void doStuff() {}
    }
```
```scala
// scala code:
    @Foo
    class Blah {
      @Stuff
      def doStuff(): Unit = ()
    }
```
* Same annotation usage syntax.
* Annotations are not used very often in Scala.
* The extra power of lambdas, types and implicits means that the extra-linguistic meta-programming that they are required for in Java often doesn't need to happen.
* Annotations can nest, like in Java.

```java
// java code:
    strs[0]
```
```scala
// scala code:
    strs(0)
```
* There is no special syntax for arrays.
* Anything defining an apply() method can use function-like syntax like this.

```java
// java code:
    strs[0] = 5
```
```scala
// scala code:
    strs(0) = 5
```
* There is no special syntax for arrays.
* Anything defining an update() method can use assignment syntax like this.

```java
// java code:
    String[] strs = new String[] {"a", "b"}
```
```scala
// scala code:
    val strs = Array("a", "b")
```
* Arrays don't have privileged syntax; they look the same as other generic collections.
* Only use them if you need co-location in memory for high performance.
* Instead of using "new", we are calling the factory function on the Array object.
* Abstracts over the different kinds of JVM array representations int[], Object[], long[], etc, using black magic.

```java
// java code:
    Integer a = 4; // box
    int a = b; // unbox
```
```scala
// scala code:
    val a: AnyRef = 4 // box
    val b: Int = a.asInstanceOf[Int] // unbox
```
* Autoboxing and unboxing happens automatically and invisibly.
* See Primitives.

```java
// java code:
    public class Point {
      private final int x, y;
    
      static class Builder {
        int x = 0;
        int y = 0;
    
        public void withX(int x) { 
          this.x = x; 
        }
    
        public void withY(int y) { 
          this.y = y 
        }
        public Point build() {...}
      }
    
      public int getX() {
        return x;
      }
    
      public int getY() {
        return y;
      }
      // and on and on and on with more fields
    }
```
```scala
// scala code:
    class Point(val x: Int = 3, val y = 77)
    // x = 5, y = 77
    new Point(x = 5)
```
* Scala has named and default parameters.
* You can use this with regular constructors and factory methods, no need for builders.

```java
// java code:
    (Banana)myFruit
```
```scala
// scala code:
    myFruit.asInstanceOf[Banana]
```
* Casting doesn't have a special syntax, it is a method.
* The syntax is deliberately verbose, to discourage casting.
* Casts are not very idiomatic Scala; mostly the type system should protect you from having to lie to it.

```java
// java code:
    public class Gumble {}
```
```scala
// scala code:
    class Gumble
```
* Everything is public by default.
* Don't need braces if there's no content.

```java
// java code:
    public class Shoe implements 
        Shineable, Cobbleable, Wearable {}
```
```scala
// scala code:
    class Shoe extends Shineable 
        with Cobbleable with Wearable
```
* The first thing always says "extends", even if it is a trait.
* "with" for everything else.
* This determines the order in which trait mixins are applied.

```java
// java code:
    public class Point {
      private final int x, y;
    
      public Point(int x, int y) {
        this.x = x;
        this.y = y;
      }
    
      public int x() { 
        return x; 
      }
    
      public int y() { 
        return y; 
      }
    }
```
```scala
// scala code:
    class Point(val x: Int, val y: Int)
```
* Adding "val" makes the constructor arg bind to a field of the same name.
* "Instance variables" are actually hidden; what you call is always an accessor method, that can be overridden.

```java
// java code:
    public class Gumble extends Foo {
      public Gumble(String id) {
        super(id)
      }
    }
```
```scala
// scala code:
    class Gumble(id: String) extends Foo(id)
```
* Primary constructor goes in the declaration.
* Type comes after the identifier.

```java
// java code:
    enum Suit {SPADES, HEARTS, CLUBS, DIAMONDS}
    Suit suit = Suit.SPADES;
```
```scala
// scala code:
    // Algebraic Data Type (ADT)
    sealed trait Suit
    case object Spades extends Suit
    case object Hearts extends Suit
    case object Clubs extends Suit
    case object Diamonds extends Suit
    val suit: Suit = Spades
    
    // OR
    
    // Enumeration class
    object Suit2 extends Enumeration {
      val Spades, Hearts, Clubs, Diamonds = Value
    }
    
    val suit2: Suit2.Value = Suit2.Spades
```
* Scala doesn't directly support enums; one of the few things in Java that can't be generated from Scala. People constantly complain about this, but you really don't need them.
* There are two techniques commonly used; Algebraic Data Types, which are more general and powerful, and the Enumeration mixin, which is less powerful.
* ADTs are a closed hierarchy of ordinary classes and objects; here we are using top-level objects, because we require no parameters.
* "case class" and "case object" is syntax sugar that generates fields, hashcode, equals, toString and factory methods. They are ordinary classes/objects that you could otherwise have defined by hand. Here, "case object" just gives us a toString() the same as the identifier name.
* The Enumeration mixin defines a type Value; the Value method creates a new value of type Value.
* Notice that unlike most languages, comma-separated declarations get assigned to every variable in the list, not just the last one.
* Usually you would prefer ADTs; the Enumeration mixin is quite limited in usage.

```java
// java code:
    obj1.equals(obj2);
    primitive1 == primitive1;
```
```scala
// scala code:
    any1 == any2
```
* == is a method that everything supports.
* It calls the equals() method on objects.
* It checks value equality on primitives.
* It is null-safe.

```java
// java code:
    obj1 == obj2
```
```scala
// scala code:
    obj1 eq obj2
```
* eq is a method that all objects (any class under AnyRef) support.
* Reference equality is not usually used in functional programming.
* If the reference provides object identity, then it implies that the state of the object mutates over time.
* In FP, identity is usually modelled outside of object instances.

```java
// java code:
    public interface FooFactory {
      public Foo createFoo();
    }
```
```scala
// scala code:
    () => Foo
```
* I mean, it's really just a function, isn't it.

```java
// java code:
    for (int i=0; i < max; i++) {
      doStuff(i);
    }
```
```scala
// scala code:
    // Low level equivalent
    var i = 0
    while (i < max) {
      doStuff(i)
      i += 1
    }
    
    // Index counting equivalent
    for (i <- 0 until max) {
      doStuff(i)
    }
    
    // Obtain index alongside item with combinators
    for ((item, i) <- myList.zipWithIndex) {
      doStuff(item, i)
    }
```
* There's no direct equivalent to the low-level for loop; you would need to use while.
* No one has used this in Java since 1999 anyway.
* You can use a for-comprehension if you just want run through a range.
* start.to(includedEnd).by(step) and start.until(excludedEnd).by(step) are the most common methods used to create range objects.
* The "to" and "until" methods are supported on all numeric types.
* The range is a collection, although it doesn't explicitly store all of the numbers in range, of course.
* At the cost of an extra iteration, the most concise way to obtain the index alongside elements in a sequence is zipWithIndex.
* "0 until max" is the same as "0.until(max)". Any instance method can be written in operator style.

```java
// java code:
    List reversedNames = new ArrayList();
    for (String n : nameList) {
      reversedNames.add(n.reverse());
    }
    return reversedNames;
```
```scala
// scala code:
    for (n <- nameList) yield n.reverse
    
    // which is sugar for:
    
    nameList.map(_.reverse)
```
* Using "yield" with a for-comprehension makes it a functional statement, returning the same kind of structure with the transformation applied.
* This is syntax sugar for calling the shown map() function.
* The underscore represents the first argument of a closure; it is shorthand for (n => n.reverse).

```java
// java code:
    for (String n : nameList) {
      System.out.println("Hi, " + n);
    }
```
```scala
// scala code:
    for (n <- nameList) {
      println("Hi, " + n)
    }
    
    // which is sugar for:
    
    nameList.foreach(n => println("Hi, " + n)
```
* The for-comprehension syntax is just sugar for the foreach() method here. Anything that defines a foreach method can use a for-comprehension in this way.
* The imperative for-comprehension yields () (Unit) as a value.

```java
// java code:
    public class Foo {
      public  void blah(X x, Y y) {}
    }
```
```scala
// scala code:
    class Foo[A, B] {
      def blah[X, Y](x: X, y: Y): Unit = {}
    }
```
* Same concept, although Scala uses square brackets.

```java
// java code:
    public class Muncher {
      public void munch(S munchable) {...}
    }
```
```scala
// scala code:
    class Muncher[S >: Snack] {
      def munch(munchable: S): Unit
    }
```
* Uses the special >: operator instead of "super".

```java
// java code:
    public class Vendor {
      public S vend() {...}
    }
```
```scala
// scala code:
    class Vendor[S <: Snack] {
      def vend(): S = ...
    }
```
* Uses the special <: operator instead of "extends".

```java
// java code:
    BurlapSack wildcardSack = new BurlapSack();
    BurlapSack rawSack = new BurlapSack();
```
```scala
// scala code:
    val wildcardList: Seq[_] = Vector.empty
```
* Underscore indicates a wildcard.
* There are no raw types in Scala; you always have to fill in type parameters.

```java
// java code:
    Muncher = new Muncher();
```
```scala
// scala code:
    val muncher: Muncher[_ >: Snack] = new Muncher[Food]
```
```java
// java code:
    Vendor vendor = 
        new Vendor();
```
```scala
// scala code:
    val vendor: Vendor[_ <: Snack] = 
        new Vendor[OverpricedCookies]
```
```java
// java code:
    if (cond) {
      doStuff();
    }
    else {
      otherStuff();
    }
```
```scala
// scala code:
    if (cond) {
      doStuff()
    }
    else {
      otherStuff()
    }
```
```java
// java code:
    cond ? stuff : otherStuff
```
```scala
// scala code:
    if (cond) stuff else otherStuff
```
* Why have two syntaxes for the same thing? There's no ternary operator, because it's redundant.

```java
// java code:
    import com.baz.Baz;
    import com.foo.Frunk;
    import com.foo.Bazzle;
    import com.foo.bar.*;
```
```scala
// scala code:
    import com.baz.Baz
    import com.foo.{Frunk, Bazzle}
    import com.foo.bar._
```
* You can stack multiple imports from the same package in braces.
* Underscore means "all" here.

```java
// java code:
    int i;
    i++;
    ++i;
    i--;
    --i;
```
```scala
// scala code:
    var i: Int
    i += 1
    i -= 1
```
* There are no special pre/post/inc/dec operators.
* \+ is a normal method on Int.
* Assignment statements have the value of () (Unit), so you can't embed assignments in other expressions and conditional tests.
* The = part is assignment shorthand that can apply to any method with a symbolic name  
Therefore it all desugars as: 
    
        i = i.+(1)
    i = i.-(1)

```java
// java code:
    foo instanceof Banana
```
```scala
// scala code:
    foo.isInstanceOf[Banana]
```
* Uses a method rather than special syntax.
* Similar to cast method: asInstanceOf[Type].

```java
// java code:
    public class Foo {
      private String muta = "m";
    
      public String getMuta() {
        return muta;
      }
    
      public void setMuta(String m) {
        muta = m;
      }
    }
```
```scala
// scala code:
    class Foo {
      var muta = "m"
    }
    
    // OR fully written out: 
    
    class Foo {
      private var mVar = "m"
    
      def muta: String = mVar
    
      def muta_=(m: String): Unit = { mVar = m }
    }
```
* Just writing "var" in the class body will define a field, with an accessor and mutator for that name.
* You can write the accessors/mutators in full; a method name that ends in "_=" will get natural "a.b = c" assignment syntax sugar.
* Both of these classes do the same thing.
* Generally prefer immutable vals to mutable vars.

```java
// java code:
    public class Foo {
      private final int fixed = 5;
    
      public int getFixed() {
        return fixed;
      }
    }
```
```scala
// scala code:
    class Foo {
      val fixed = 5
    }
```
* "fixed" is the name of an accessor method. The actual field is hidden.

```java
// java code:
    public interface Edible {
      public abstract boolean containsBones();
      public abstract void eatWith(Drink drink);
    }
```
```scala
// scala code:
    trait Edible {
      def containsBones: Boolean
      def eatWith(drink: Drink): Unit
    }
```
* Traits are like interfaces, except they can contain code that gets mixed with the class and other traits.
* If there is no "=" assignment, then the def/var/val is abstract.
* "Unit" is the same as "void".

```java
// java code:
    List list;
    new ArrayList(list).add("newvalue");
    new ArrayList(list).insert(0, "newvalue")
```
```scala
// scala code:
      val list: Seq[String]
      list :+ "newvalue"
      "newvalue" +: list
```
* The +: method means "prepend".
* The :+ method means "append".
* Methods ending in : associate to the right, so the +: call is actually the same as list.+:("newvalue")
* These return new lists, without modifying the old ones.
* They reuse as much of the old structure as possible.

```java
// java code:
    List list;
    list.add("newvalue")
    list.insert(0, "newvalue")
```
```scala
// scala code:
    val list: scala.collection.mutable.Buffer[String]
    list += "newvalue"
    list.insert(0, "newvalue")
```
* Mostly you won't need the mutable stuff. Use the default immutable Seqs instead, unless there's a compelling performance or clarity argument.
* Similar syntax to Java, but with a += method instead of "add".

```java
// java code:
    List list1;
    new ArrayList(list1).addAll(list2);
```
```scala
// scala code:
    val list: Seq[Foo]
    list1 ++ list2
```
* ++ is an ordinary method, returning a new list.
* Neither old list gets modified.
* The resulting list reuses as much of the old structures as it can.

```java
// java code:
    List list1;
    list1.addAll(list2)
```
```scala
// scala code:
    val list1: scala.collection.mutable.Buffer[Foo]
    list1 ++= list2
```
* Mostly you won't need the mutable stuff. Use the default immutable Seqs instead, unless there's a compelling performance or clarity argument.
* The ++= method mutates the first list.

```java
// java code:
    ??? You could use Guava, or the crappy unmodifiable wrappers.
```
```scala
// scala code:
    val list: Seq[String] = Vector("hello", "world")
```
* Seq is the default trait for ordered sequences.
* Vector is the best default implementation. It has practically constant time access and modification, yet is totally immutable, and shares most of its structure.
* The companion object of Vector (as with all of the collections) defines an apply() factory method, which will return an efficient implementation for the size you have chosen.

```java
// java code:
    List list = new ArrayList();
    list.add("hello");
    list.add("world");
```
```scala
// scala code:
    import scala.collection.mutable
    val list: mutable.Seq[String] = mutable.ArrayBuffer("hello", "world")
```
* Mostly you won't need the mutable stuff. Use the default immutable Seqs instead, unless there's a compelling performance or clarity argument.
* The ArrayBuffer companion object defines an apply() factory method, which produces an appropriate instance of ArrayBuffer.
* Way better type inference.

```java
// java code:
    List list;
    list.get(0);
```
```scala
// scala code:
    val list: Seq[String]
    list(0)
```
* Seq is the default trait for ordered sequences.
* Seq[A]s actually extend (Int => A), so they not only look like functions, but are functions.

```java
// java code:
    List list;
    list.set(3, "newvalue")
```
```scala
// scala code:
    val list: scala.collection.mutable.Buffer[String]
    list(3) = "newvalue"
```
* Mostly you won't need the mutable stuff. Use the default immutable Seqs instead, unless there's a compelling performance or clarity argument.
* Mutable Seqs define an update() method, that enables the special assignment syntax sugar.

```java
// java code:
    List oldList;
    new ArrayList(oldList).set(3, "newvalue");
```
```scala
// scala code:
    val oldList: Seq[String]
    oldList.updated(3, "newvalue")
```
* Returns a new immutable Seq without modifying the old one.
* Reuses as much of the old structure as it can.

```java
// java code:
    Map map;
    map.get(key);
```
```scala
// scala code:
    val map: Map[Key, Value]
    map(key)
```
* Maps define an apply() function, which allows them to have a function-like access syntax.
* Immutable Map[K,V]s actually extend (K => V), so they not only look like functions, but are functions.

```java
// java code:
    Map map;
    new HashMap(map1).putAll(map2);
```
```scala
// scala code:
    val map1: Map[Key, Value]
    map1 ++ map2
```
* Maps are integrated into Scala's collection hierarchy as a Iterable[(K, V)].
* ++ is the concatenation method defined on all immutable collections.
* ++ returns a new map, without changing the old ones. Reuses as much of the old maps in memory as possible.

```java
// java code:
    Map map1;
    map1.putAll(map2)
```
```scala
// scala code:
    val map1: scala.collection.mutable.Map[Key, Value]
    map1 ++= map2
```
* Mostly you won't need the mutable stuff. Use the default immutable Maps instead, unless there's a compelling performance or clarity argument.
* Maps are integrated into Scala's collection hierarchy as a Iterable[(K, V)].
* The ++= is a regular method.

```java
// java code:
    ??? You could use Guava, or the crappy unmodifiable wrappers.
```
```scala
// scala code:
    val map = Map("foo" -> 5, "bar" -> 6)
```
* Maps are immutable by default, and have efficient access, "insertion", "update", and "remove" characteristics.
* Everything is implicitly extended with the -> method. It's actually a regular method that you could have written, that returns a pair.
* The Map companion object defines an apply() factory method, that produces the most efficient implementation for the map size you've defined.
* Way better type inference.

```java
// java code:
    Map map = new HashMap();
    map.put("Potatoes", 5);
    map.put("Bananas", 7);
```
```scala
// scala code:
    import scala.collection.mutable
    val map = mutable.Map("Potatoes" -> 5, "Bananas" -> 7)
```
* Mostly you won't need the mutable stuff. Use the default immutable Maps instead, unless there's a compelling performance or clarity argument.
* Everything is implicitly extended with the -> method. It's actually a regular method that you could have written, that returns a pair.
* The HashMap companion object defines an apply() factory method, that produces the most efficient implementation for the map size you've defined so far.
* Way better type inference.

```java
// java code:
    Map map;
    new HashMap(map).put(key, value)
```
```scala
// scala code:
    val map: Map[Key, Value]
    map + (key, value)
```
* The + method returns a new map, without modifying the old one. This is very efficient, and will reuse most of the memory representation of the old one.
* ("foo", 44) is syntax sugar for a new Tuple2[String, Int]("foo", 44). Other length tuples have equivalent syntax.
* The inserted pair could also be produced with the -> method: "foo" -> 44\. -> is an extension method provided on everything.

```java
// java code:
    Map map;
    map.put(key, value);
```
```scala
// scala code:
    val map: scala.collection.mutable.Map[Key, Value]
    map += (key, value)
```
```java
// java code:
    Map map;
    map.put(key, value);
```
```scala
// scala code:
    val map: scala.collection.mutable.Map[Key, Value]
    map(key) = value
```
* Mostly you won't need the mutable stuff. Use the default immutable Maps instead, unless there's a compelling performance or clarity argument.
* Mutable maps define an update() method, which allows them to have this special assignment syntax sugar.

```java
// java code:
    public String myMethod(int arg1, boolean arg2) { 
      return "foo"; 
    }
```
```scala
// scala code:
    def myMethod(arg1: Int, arg2: Boolean): String = "foo"
```
* Methods are introduced with "def".
* Return type comes after the method
* "=" marks the implementation

```java
// java code:
    abstract int doStuff(int blah);
```
```scala
// scala code:
    def doStuff(blah: Int): Int
```
* If there's no definition provided with "=", then it's automatically abstract.
* It's there for Java interop, but don't use it. See "Optional value".

```java
// java code:
    String missing = null;
    String gotIt = "value";
```
```scala
// scala code:
    val missing: Option[String] = None
    val gotIt: Option[String] = Some("value")
```
* Option is what you want. Some(x) indicates a value, None indicates its absence.
* You can actually use "null", but don't, ever. It's just there for Java interop.
* Option gets treated like a 0- or 1-length collection, and has all the same powerful combinators that collections do, like map, filter, flatMap, and foreach.

```java
// java code:
    foo == null ? "nope" : "got " + foo;
```
```scala
// scala code:
    foo.map("got " + _).getOrElse("nope")
```
* "map" and "getOrElse" are regular methods on Option.
* The "_" indicates the first arg of a lambda. Shorthand for (x => "got " + x).

```java
// java code:
    if (foo != null) {
      System.out.println("got " + foo)
    }
    else {
      System.out.println("nope")
    }
```
```scala
// scala code:
    foo match {
      case Some(f) => println("got " + f)
      case None => println("nope")
    }
```
* Pattern matching provides a convenient way to dispatch on the optional case.

```java
// java code:
    package blah;
```
```scala
// scala code:
    package blah
```
```java
// java code:
    int i = 5;
    boolean b = true;
    char c = 'c';
    long L = 55L;
    short s = 3;
    byte x = 1;
    double d = 3.0;
    float f = 5.0f;
```
```scala
// scala code:
    val i: Int = 5
    val b: Boolean = true
    val c: Char = 'c'
    val L: Long = 55L
    val s: Short = 3
    val x: Byte = 1
    val d: Double = 3.0
    val f: Float = 5.0f
```
* The type system is unified; everything, including primitives is a subtype of Any.
* Autoboxing and unboxing happens automatically and invisibly.
* All primitives are conceptually objects and support several instance methods.
* If possible, they will compile to efficient primitive JVM values.
* Int, Boolean, Char, etc are not keywords — they are class names.

```java
// java code:
    System.out.println("Hello!")
```
```scala
// scala code:
    println("Hello!")
```
* This is defined in scala.Predef, which automatically gets imported.

```java
// java code:
    public  T pretendReified(Class token);
    
    Banana b = pretendReified(Banana.class)
```
```scala
// scala code:
    def pretendReified[T: ClassTag](): T
    // which is syntax sugar for:
    def pretendReified[T](implicit token: ClassTag[T])
    
    val b = pretendReified[Banana]
```
* We can get around the lack of reified types with a runtime type token, like in Java.
* If an implicit ClassTag[T] is required, the compiler will insert it; no need to manually provide one.
* The [A : Foo] syntax is sugar for requiring an implicit parameter of type Foo[A].

```java
// java code:
    public enum Singleton { INSTANCE }
```
```scala
// scala code:
    object Singleton
```
* Scala has top-level singleton objects.
* These are used as a superior alternative to statics.
* They can mix in traits, extend classes, and include any functionality that classes or traits do.
* "Singleton" here is the name of the value; if you want to refer to its type, you can say Singleton.type. In fact, you get the singleton type of of any fixed value with the .type syntax.

```java
// java code:
    public class Foo {
      public static Foo createFoo(String stuff) {
        return new MysteryFoo(stuff);
      }
    }
    Foo f = Foo.createFoo("stuff");
```
```scala
// scala code:
    object Foo {
      def apply(stuff: String): Foo = new MysteryFoo(stuff)
    }
    
    class Foo
    val f: Foo = Foo("stuff")
```
* The most common idiom for static factory methods is an apply() method on the companion object.
* All the collections follow this idiom.
* All case classes follow this idiom.
* apply() methods allow syntax sugar where the receiver object can be called like a function.

```java
// java code:
    public class Statics {
      public static final int SPIDER_LEGS = 8;
    
      public static int getHumanLegs() {
        return 2;
      }
    }
    int n = Statics.SPIDER_LEGS;
```
```scala
// scala code:
    object Statics {
      val SpiderLegs = 8
      def humanLegs = 2
    }
    class Statics
    val n = Statics.SpiderLegs
```
* There is no such thing as static in Scala.
* You can define a top-level object with the same name as your class; this is called a "companion object", and so you can get the same static access syntax as Java.
* There are only two namespaces, values and types. The object is a value, the class is a type; that's why they can have the same name.
* The object can extend classes and apply mixins, so you can abstract and reuse the functionality much better.
* The all-capitals syntax is not typically used, because it doesn't really make sense to differentiate them; they are all really instance accessor methods.

```java
// java code:
    public interface TaxStrategy {
      public int calculateTax(Citizen c);
    }
    
    public void calcTax(TaxStrategy strat) {
      int totalTax = 0;
    
      for (Citizen c : citizens) {
        totalTax += strat.calculateTax(c);
      }
      return totalTax;
    }
```
```scala
// scala code:
    def calcTax(f: Citizen => Int) = citizens.map(f).sum
```
* This is what functions are for.
* These are the kind of silly concepts that don't need to exist in your codebase if you have lambdas and function types.

```java
// java code:
    "foo " + something
```
```scala
// scala code:
    "foo " + something
    s"foo ${something}"
```
* Same + syntax as Java.
* You can also use the interpolation syntax, by putting an "s" before the string literal, and using the $ sign in the string.

```java
// java code:
    Object value;
    try {
      value = calculateValue();
    } catch (SomeException e) {
      value = backupValue;
    }
```
```scala
// scala code:
    value = try {
      calculateValue()
    } catch {
      case e: SomeException => backupValue
    }
```
* Like everything else, try/catches are expressions, and always evaluate to a value.
* The "catch" part expects a regular PartialFunction[Throwable, _]. It allows much more flexible matching than Java's special syntax. The most common way to provide it is using the pattern-matching block syntax, which is a partial function literal.

```java
// java code:
    try {
      doStuff();
    }
    catch (BlahException e) {
      e.printStackTrace();
    }
    catch (FooException e) {
      e.printStackTrace();
    }
    finally {
      System.out.println("done");
    }
```
```scala
// scala code:
    try {
      doStuff()
    }
    catch {
      case e: BlahException => e.printStackTrace()
      case e: FooException => e.printStackTrace()
    }
    finally {
      println("done")
    }
```
* Almost the same syntax.
* The "catch" part expects a regular PartialFunction[Throwable, _]. It allows much more flexible matching than Java's special syntax. The most common way to provide it is using the pattern-matching block syntax, which is a partial function literal.

```java
// java code:
    public void stuff(String... names) {}
    
    // Varargs call
    stuff("foo", "bar")
    
    // Directly call with String[]
    stuff(new String[] {"foo", "bar"})
```
```scala
// scala code:
    def stuff(names: String*)
    
    // Varargs call
    stuff("foo", "bar")
    
    // Directly call with Seq[String]
    stuff(Seq("foo", "bar"): _*)
```
* Declaring a varargs method uses * instead of …
* When directly calling with a pre-built Seq of things, you need to ascribe the value with the special type of _*. This helps avoid unpleasantness and confusion.
* Actually, any value can be ascribed with a type, which is like an upcast in the compiler, eg (4: Any), which has a compile-time type of Any, and a runtime type of Int.

```java
// java code:
    void doStuff() {}
```
```scala
// scala code:
    def doStuff(): Unit = ()
```
* Everything is a value in Scala.
* void methods actually return a useless primitive value (), called Unit.
* It compiles to void on the JVM.
* Assignments, while loops and imperative for-comprehensions also have the value of Unit.

```java
// java code:
    while (someCondition()) {
      doStuff();
    }
```
```scala
// scala code:
    while (someCondition) {
      doStuff()
    }
    
    // OR
    
    @tailrec
    def whileLoop(): Unit = {
      if (someCondition) {
        doStuff()
        whileLoop()
      }
    }
```
* The while loop is inherently imperative, and has a value of () (Unit).
* This is a low level looping construct, the same as Java's. It is usually only used for high-performance tuning when the various map, flatMap, and filter combinators would be too slow or memory hungry. eg, painting a grid of pixels on screen.
* A tail-recursive function will compile to the same efficient bytecode as a while loop.
* The @tailrec annotation is not required, but makes the compiler guarantee that the recursion will reuse the same space on the stack.
* These are the only ways to simulate Java's low-level for(;;) loop.

This entry was posted in [Engineering][1] by [Ken Scambler][2]. Bookmark the [permalink][3]. 

[1]: http://rea.tech/engineering/
[2]: http://rea.tech/author/ken-scamblerrea-group-com/
[3]:  "Permalink to Java to Scala cheatsheet"

### From scala
对比学习别人Clojure封装Scala: https://github.com/clojure-spark/from-scala
```clojure
[t6/from-scala "0.2.1"]
[org.scala-lang/scala-library "2.11.6"]

(:require [t6.from-scala.core :refer ($ $$) :as $] ...)

($ ($ List & 1 2 3 4)
   reduce
   ($/function [x y] (+ x y))))
;; => 10
```
